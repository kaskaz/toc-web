import React from 'react';
import Head from 'next/head'

import { makeStyles } from '@material-ui/core'
import Content from '../components/content/Content';
import Footer from '../components/footer/Footer';
import Header from '../components/header/Header';

import "@fontsource/open-sans";
import "@fontsource/gentium-book-basic";
import { GetServerSideProps, InferGetServerSidePropsType } from 'next';

import CONFIG from '../../firebase';
import * as firebase from 'firebase/app';
import { collection, doc, getFirestore, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";

import Poll from '../models/poll';

const useStyles = makeStyles({
  container: {
    minHeight: '100%',
    padding: '0 0.5rem',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    height: '100%',
    backgroundColor: '#f13b3b'
  }
});

export default function Home({ config, polls }: InferGetServerSidePropsType<typeof getServerSideProps>) {
  const classes = useStyles();
  return (
    <div className={classes.container}>
      <Head>
        <title>The Original Cover</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <script async src="/widgets.js"></script>

        <script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="jyLcVvzLvEnxEDLcQaFzolcRV6Jrbw75"></script>
      </Head>
      <Header />
      <Content config={config} polls={polls} />
      <Footer />
    </div>
  )
}

type Vote = {
  pollId: string;
  originalVotes: number;
  coverVotes: number;
}

export const getServerSideProps: GetServerSideProps = async (context) => {

  const app = firebase.initializeApp(CONFIG);
  const database = getFirestore(app);

  const configResponse = await getDoc(doc(database, '/poll-config/config'));
  const votesResponse = await getDocs(collection(database, '/votes'));
  const pollsResponse = await getDocs(
    query(
        collection(database, '/polls'),
        where('isEnabled', '==', true),
        orderBy('number', 'desc')
    )
  );

  if(!configResponse.exists() || pollsResponse.empty || votesResponse.empty) {
    return {
      notFound: true
    }
  }

  let configData = configResponse.data();
  const config = {
    twitterStatusPart: configData.twitterStatusPart,
    twitterVoteCoverPart: configData.twitterVoteCoverPart,
    twitterVoteOriginalPart: configData.twitterVoteOriginalPart,
    twitterVoteStartPart: configData.twitterVoteStartPart
  };

  let polls: Poll[] = [];
  let votes: Vote[] = votesResponse.docs.map(doc => { 
    return {
      pollId: doc.data().id,
      originalVotes: doc.data().cover?.length | 0,
      coverVotes: doc.data().original?.length | 0
    }
  });
  
  pollsResponse.forEach(poll => {
    let data = poll.data();
    let pollVotes = votes.find(pv => pv.pollId === data.twitterStatus);

    if(pollVotes) {
      polls.push(
        {
          id: poll.id,
          number: data.number,
          songName: data.songName,
          originalArtist: data.artistNameOriginal,
          coverArtist: data.artistNameCover,
          artistDetailsOriginal: data.artistDetailsOriginal,
          artistDetailsCover: data.artistDetailsCover,
          votesOriginal: pollVotes.originalVotes,
          votesCover: pollVotes.coverVotes,
          youtubeCoverVideoUrl: data.youtubeCoverVideo,
          youtubeOriginalVideoUrl: data.youtubeOriginalVideo,
          artistWebsiteCover: data.artistWebsiteCover,
          artistWebsiteOriginal: data.artistWebsiteOriginal,
          twitterStatus: data.twitterStatus
        }
      );
    }
  });

  return {
    props: {
      config,
      polls
    }
  }
}; 
